// pages/api/transcript.js
import { YoutubeTranscript } from 'youtube-transcript';
import fetch from 'node-fetch';

// Configure for Vercel serverless environment
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '1mb',
    },
    responseLimit: '8mb',
    externalResolver: true,
  },
};

// Add this at the top of your file for better error handling
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

const isAllowedDomain = (url) => {
  try {
    // Parse the URL to get the hostname
    const hostname = new URL(url).hostname;
    
    // Get allowed domains from environment variable
    const allowedDomains = process.env.DOMAIN_ALLOWED 
      ? process.env.DOMAIN_ALLOWED.split(',').map(d => d.trim())
      : [];
    
    // Check if the hostname matches or is a subdomain of any allowed domain
    return allowedDomains.some(domain => 
      hostname === domain || hostname.endsWith(`.${domain}`)
    );
  } catch (error) {
    console.error('Error checking domain:', error);
    return false;
  }
};

async function getVideoMetadata(videoId) {
  const userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36';
  
  try {
    console.log('[METADATA] Fetching video metadata for:', videoId);
    const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
      headers: {
        'User-Agent': userAgent,
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch video page: ${response.status}`);
    }
    
    const html = await response.text();
    console.log('[METADATA] Successfully fetched video page');
    
    let title = 'Untitled Video';
    let description = 'No description available';
    let author = 'Unknown Author';

    // Try different ways to extract metadata
    const dataMatches = [
      html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/),
      html.match(/ytInitialData\s*=\s*({.+?});/),
      html.match(/<script[^>]*>var ytInitialData = ({.+?});<\/script>/)
    ];

    for (const match of dataMatches) {
      if (match) {
        try {
          const data = JSON.parse(match[1]);
          console.log('[METADATA] Successfully parsed YouTube data');
          
          // Try different paths to get video details
          const videoDetails = 
            data.videoDetails || 
            data.contents?.twoColumnWatchNextResults?.results?.results?.contents?.[0]?.videoPrimaryInfoRenderer ||
            data.contents?.twoColumnWatchNextResults?.results?.results?.contents?.[0]?.videoSecondaryInfoRenderer;

          if (videoDetails) {
            title = videoDetails.title || videoDetails.videoTitle || title;
            description = videoDetails.shortDescription || videoDetails.description || description;
            author = videoDetails.author || videoDetails.ownerChannelName || author;
            break;
          }
        } catch (e) {
          console.log('[METADATA] Failed to parse data format:', e.message);
          continue;
        }
      }
    }

    // If we still don't have metadata, try regex fallbacks
    if (title === 'Untitled Video') {
      const titleMatch = html.match(/<title>([^<]+)<\/title>/) || html.match(/"title":"([^"]+)"/);
      if (titleMatch) title = titleMatch[1].replace(' - YouTube', '');
    }

    if (description === 'No description available') {
      const descMatch = html.match(/"description":\{"simpleText":"([^"]+)"\}/) || 
                       html.match(/"description":"([^"]+)"/);
      if (descMatch) description = descMatch[1];
    }

    if (author === 'Unknown Author') {
      const authorMatch = html.match(/"author":"([^"]+)"/) || 
                        html.match(/"ownerChannelName":"([^"]+)"/);
      if (authorMatch) author = authorMatch[1];
    }

    console.log('[METADATA] Final metadata:', { title, description: description.substring(0, 100) + '...', author });
    return { title, description, author };
  } catch (error) {
    console.error('[METADATA] Error fetching metadata:', error);
    return {
      title: 'Untitled Video',
      description: 'No description available',
      author: 'Unknown Author'
    };
  }
}

async function fetchTranscript(videoId) {
  const userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36';
  console.log(`[TRANSCRIPT] Starting fetch for video ID: ${videoId}`);
  
  try {
    // First try the default method with retries
    for (let i = 0; i < 3; i++) {
      try {
        console.log(`[TRANSCRIPT] Attempt ${i + 1} using primary method`);
        const transcriptList = await YoutubeTranscript.fetchTranscript(videoId, {
          lang: 'en',
          country: 'US'
        });
        
        if (transcriptList && transcriptList.length > 0) {
          console.log(`[TRANSCRIPT] Successfully fetched transcript using primary method`);
          return transcriptList;
        }
      } catch (primaryError) {
        console.log(`[TRANSCRIPT] Primary method attempt ${i + 1} failed:`, primaryError.message);
        if (i < 2) await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second between retries
      }
    }

    console.log(`[TRANSCRIPT] All primary attempts failed, trying fallback method`);
    // If the first method fails, try with fetch
    const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
      headers: {
        'User-Agent': userAgent,
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Upgrade-Insecure-Requests': '1'
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch video page: ${response.status}`);
    }
    
    const html = await response.text();
    
    // Try to extract captions data from the page
    console.log('[TRANSCRIPT] Searching for captions in HTML...');
    
    // First try manual captions
    let captionsMatch = html.match(/"captionTracks":\[(.+?)\]/);
    
    // If no manual captions, try auto-generated captions
    if (!captionsMatch) {
      console.log('[TRANSCRIPT] No manual captions found, checking for auto-generated...');
      captionsMatch = html.match(/"playerCaptionsTracklistRenderer":\{(.+?)\}\]/);
      
      if (!captionsMatch) {
        console.log('[TRANSCRIPT] Trying alternative caption format...');
        // Try another format that sometimes appears
        captionsMatch = html.match(/"playerCaptionsRenderer":\{(.+?)\}\]/);
      }
      
      if (!captionsMatch) {
        throw new Error('No caption tracks found');
      }
    }

    const captionsData = JSON.parse(`[${captionsMatch[1]}]`);
    console.log('[TRANSCRIPT] Caption data found:', JSON.stringify(captionsData, null, 2));
    
    // Try to find English captions with more flexible matching
    const englishCaptions = captionsData.find(c => {
      const hasEnglishCode = c.languageCode === 'en' || c.languageCode?.startsWith('en-');
      const hasEnglishName = c.name?.simpleText?.toLowerCase().includes('english') ||
                           c.name?.toLowerCase().includes('english');
      return hasEnglishCode || hasEnglishName;
    });
    
    if (!englishCaptions) {
      console.log('[TRANSCRIPT] No English captions found in:', captionsData);
      throw new Error('No English captions available');
    }
    
    const captionUrl = englishCaptions.baseUrl || englishCaptions.url;
    if (!captionUrl) {
      console.log('[TRANSCRIPT] No caption URL found in:', englishCaptions);
      throw new Error('No caption URL available');
    }
    
    console.log('[TRANSCRIPT] Found caption URL:', captionUrl);

    const transcriptResponse = await fetch(captionUrl, {
      headers: {
        'User-Agent': userAgent,
        'Accept-Language': 'en-US,en;q=0.9',
      }
    });
    
    if (!transcriptResponse.ok) {
      throw new Error(`Failed to fetch transcript XML: ${transcriptResponse.status}`);
    }
    
    const transcriptXml = await transcriptResponse.text();
    
    const matches = transcriptXml.match(/<text.+?>([^<]+)<\/text>/g);
    if (!matches) {
      throw new Error('Failed to parse transcript XML');
    }

    const transcriptList = matches.map((item, index) => {
      const startMatch = item.match(/start="([\d\.]+)"/);
      const durMatch = item.match(/dur="([\d\.]+)"/);
      const textMatch = item.match(/>([^<]+)</);
      
      return {
        offset: startMatch ? Math.floor(parseFloat(startMatch[1]) * 1000) : index * 5000,
        duration: durMatch ? Math.floor(parseFloat(durMatch[1]) * 1000) : 5000,
        text: textMatch ? textMatch[1].replace(/&amp;/g, '&').replace(/&quot;/g, '"') : ''
      };
    });
    
    if (transcriptList.length > 0) {
      console.log(`[TRANSCRIPT] Successfully fetched transcript using fallback method`);
      return transcriptList;
    }
    
    throw new Error('No transcript entries found in the response');
  } catch (error) {
    console.error(`[TRANSCRIPT] Error fetching transcript:`, error);
    throw error;
  }
}

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  console.log('API Request received:', {
    method: req.method,
    body: req.body
  });

  try {
    console.log('Processing request body...');
    const { url } = req.body;

    if (!url) {
      return res.status(400).json({ error: 'URL is required' });
    }

    console.log('URL received:', url);

    // Check if the domain is allowed
    if (!isAllowedDomain(url)) {
      return res.status(403).json({ error: 'Domain not allowed' });
    }

    // Extract video ID from URL
    console.log('Extracting video ID from URL:', url);
    const videoId = url.match(/(?:youtube\.com\/(?:[^/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?/\s]{11})/)?.[1];

    if (!videoId) {
      return res.status(400).json({ error: 'Invalid YouTube URL' });
    }

    console.log('Extracted video ID:', videoId);
    console.log('[HANDLER] Starting parallel fetch for metadata and transcript');

    try {
      // Fetch metadata and transcript in parallel
      const [metadata, transcript] = await Promise.all([
        getVideoMetadata(videoId),
        fetchTranscript(videoId).catch(async (error) => {
          console.log('[HANDLER] Primary transcript fetch failed, trying fallback...');
          return [];
        })
      ]);

      console.log('[HANDLER] Transcript fetch complete. Length:', transcript.length);

      if (!transcript || transcript.length === 0) {
        return res.status(404).json({ error: `No transcript found for video ID: ${videoId}` });
      }

      return res.status(200).json({
        metadata,
        transcript
      });
    } catch (error) {
      console.error('[HANDLER] Error processing request:', error);
      return res.status(500).json({ error: error.message });
    }
  } catch (error) {
    console.error('[HANDLER] Unexpected error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}
